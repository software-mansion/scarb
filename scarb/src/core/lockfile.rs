use std::collections::{BTreeMap, BTreeSet};
use std::io::Write;
use anyhow::{Context, Result, bail};
use itertools::Itertools;
use semver::Version;
use serde::{Deserialize, Serialize};
use toml::to_string;

use crate::core::{Config, PackageName, SourceId, TargetKind};

#[derive(Default, PartialEq, Eq, Clone, Copy, Debug, PartialOrd, Ord, Serialize, Deserialize)]
enum LockVersion{
    #[serde(rename = "1")]
    #[default]
    V1 = 1,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
struct Lockfile {
    pub version: LockVersion,
    pub packages: BTreeMap<PackageName, PackageLock>,
}


#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
struct PackageLock {
    pub name: PackageName,
    pub version: Version,
    pub source: SourceId,
    pub dependencies: BTreeMap<PackageName, DependencyLock>,
}

#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
struct DependencyLock {
    name: PackageName,
    version: Option<Version>,
    targets: BTreeSet<TargetKind>,
}

impl Lockfile {
    pub fn add_package(&mut self, pack: PackageLock) -> Result<()> {
        if self.packages.contains_key(pack.name.as_ref()) {
            bail!("Package {} already listed in packages", pack.name)
        } else {
            self.packages.insert(pack.name.clone(), pack);
            Ok(())
        }
    }

    fn generate_lock_string(&self) -> Result<String> {
        let mut lock_str = String::new();
        let toml = toml::Table::try_from(self)?;

        // At the start of the file we notify the reader that the file is generated.
        // Specifically Phabricator ignores files containing "@generated", so we use that.
        let marker_line = "# This file is automatically @generated by Scarb.\n";
        let extra_line = "# It is not intended for manual editing.\n";
        let end_com_line = "^// Code generated .* DO NOT EDIT\\.$\n";
        lock_str.push_str(marker_line);
        lock_str.push_str(extra_line);
        // Add reusing comments from the beginning of the existing lockfile?
        lock_str.push_str(end_com_line);

        lock_str.push_str(&format!("version = {}\n\n", toml.get("version").context("failed to get version serialized lockfile toml")?));

        let packages = toml["packages"].as_table().unwrap();

        for (_, package) in packages {
            lock_str.push_str("[[package]]\n");
            lock_str.push_str(format!("name = {}\n", package["name"]).as_str());
            lock_str.push_str(format!("version = {}\n", package["version"]).as_str());
            lock_str.push_str(format!("source = {}\n", package["source"]).as_str());
            if let Some(deps) = package["dependencies"].as_table() {
                if !deps.is_empty() {
                    lock_str.push_str("dependencies = [\n");
                    for (name, dep) in deps {
                        lock_str.push_str(format!("\t\"{}", name).as_str());
                        if let Some(ver) = dep.get("version") {
                            lock_str.push_str(format!(" {}", ver.as_str().unwrap()).as_str());
                        }
                        if let Some(targets) = dep["targets"].as_array() {
                            if !targets.is_empty() {
                                lock_str.push_str(format!(" [{}]", targets.iter().map(|x| x.as_str().unwrap()).join(", ")).as_str());
                            }
                        }
                        lock_str.push_str("\",\n");
                    }
                    lock_str.push_str("]\n");
                }
            }
            lock_str.push('\n');
        }
        lock_str.pop();
        Ok(lock_str)
    }

    pub fn generate_lockfile(&self, config: &Config) -> Result<()> {
        let lock_str = self.generate_lock_string()?;
        let lockfile = config.manifest_path().parent().expect("failed to get the parent path of the manifest").join("Scarb.lock");
        let mut f = std::fs::File::create(lockfile)?;
        f.write_all(lock_str.as_ref())?;
        Ok(())
    }
}

impl TryFrom<String> for Lockfile {
    type Error = anyhow::Error;

    fn try_from(value: String) -> Result<Self> {
        // println!("1:{}", value);
        let mut value = value.lines().skip_while(|x| *x != "^// Code generated .* DO NOT EDIT\\.$").skip(1);
        let version = value.next();
        // if let Some(str) = version {
        //     // let version = str.
        //     // println!("AAAAA{version}");
        // }

        let value = value.skip(1).join("\n");
        // println!("2:{}\nend", value);
        let toml = toml::from_str(&value)?;
        println!("{:?}", toml);
        Ok(Lockfile{ version: Default::default(), packages: Default::default() })
    }
}

impl PackageLock {
    pub fn add_dependency(&mut self, dep: DependencyLock) -> Result<()> {
        if self.dependencies.contains_key(dep.name.as_ref()) {
            bail!("Package {} already has {} dependency", self.name, dep.name)
        } else {
            self.dependencies.insert(dep.name.clone(), dep);
            Ok(())
        }
    }
}


#[cfg(test)]
mod tests {
    use core::default::Default;
    use std::collections::BTreeSet;
    use semver::Version;
    use snapbox::assert_eq;
    use crate::core::lockfile::{DependencyLock, Lockfile, LockVersion, PackageLock};
    use crate::core::PackageName;

    fn prep_simple_lock() -> Lockfile {
        let dlock = DependencyLock{
            name: PackageName::STARKNET,
            version: Some(Version::parse("1.0.0").unwrap()),
            targets: BTreeSet::from(["lib".into(), "main".into()]),
        };
        let mut plock = PackageLock{
            name: PackageName::CORE,
            version: Version::parse("1.0.0").unwrap(),
            source: Default::default(),
            dependencies: Default::default(),
        };
        plock.add_dependency(dlock).unwrap();
        plock.add_dependency(DependencyLock{
            name: PackageName::new("locker"),
            version: None,
            targets: Default::default(),
        }).unwrap();
        let mut lock = Lockfile{ version: Default::default(), packages: Default::default() };
        lock.add_package(plock).unwrap();
        let mut packa = PackageLock{
            name: PackageName::STARKNET,
            version: Version::parse("1.0.0").unwrap(),
            source: Default::default(),
            dependencies: Default::default(),
        };
        packa.add_dependency(DependencyLock{
            name: PackageName::CORE,
            version: None,
            targets: Default::default(),
        }).unwrap();
        lock.add_package(packa).unwrap();
        lock.add_package(PackageLock {
            name: PackageName::new("empty"),
            version: Version::parse("4.2.0").unwrap(),
            source: Default::default(),
            dependencies: Default::default(),
        }).unwrap();
        lock
    }
    
    #[test]
    fn simple_serde() {
        let str = r#"# This file is automatically @generated by Scarb.
# It is not intended for manual editing.
^// Code generated .* DO NOT EDIT\.$
version = "1"

[[package]]
name = "core"
version = "1.0.0"
source = "registry+https://there-is-no-default-registry-yet.com/"
dependencies = [
	"locker",
	"starknet 1.0.0 [lib, main]",
]

[[package]]
name = "empty"
version = "4.2.0"
source = "registry+https://there-is-no-default-registry-yet.com/"

[[package]]
name = "starknet"
version = "1.0.0"
source = "registry+https://there-is-no-default-registry-yet.com/"
dependencies = [
	"core",
]
"#;
        let lock = prep_simple_lock();
        // println!("{}", lock.generate_lock_string().unwrap());
        assert_eq(str, lock.generate_lock_string().unwrap());
        // println!("{:?}", "version = 1".parse::<LockVersion>().unwrap());
        // let lock: Lockfile = str.to_string().try_into().unwrap();
    }
}